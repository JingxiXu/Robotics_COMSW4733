This is a Lab 2 submission for group __21__

## Team Members
Zhang Zhang (zz2517), Jingxi Xu (jx2324), Aryeh Yonatan Zapinsky (ayz2103)

Robot Name: Mark 38
 
Youtube link for bug2 demo: https://www.youtube.com/watch?v=GUnlgXMV5Ss&feature=youtu.be 

<Description of adjustments to Bug2 Algorithm>

<Descriptions of assumptions based on robot>
 
## Vidoe Explanation

The third object marks the goal which is put 180cm away from the starting point of the robot on the m-line. The robot starts on the m-line facing the object and then follows the boundaries of two obstacles, goes back to the m-line, check leaving object conditions and then finally reach the goal, which is basically the bug2 algorithm.

After the movement is finished, there is the plot generated by the robot for this movement at the end of this video.

NOTE: in the video we finally did not end exactly on the same line as we start becasue we set the m-line to be a thin band with a width of 4.6cm instead of an ideal line of 0 width. PLease see Assumptions and the plot at the end of video for details

## Implementation

Our group has successfully implemented the bug2 algorithm and plotted the trajactory of the path. Here we will explain the basic methods we used.

The robot starts forwarding 5cm per time from the strating point and then check if the first object it detects is the goal or an obstacle. If it is the goal, it moves directly to the object and stops within 5cm from the object. If there is an obstacle, it stops at within 10cm from the obstacle and then scans (turning left 1 paulse per time) until the object disapears from the sensor, so that we can make sure there is nothing in front of that direction when he starts to follow the boundary. After it finds the direction, it turns the serovo perpendicular to its body to keep tracking the distance between itself and the obstacle. It will then re-adjust itself by turning 1 paulse per time until it finds an appropriate distance from the obstacle (7cm - 15cm) and then it enters the track to follow the boundary. While following the boundary, it forwards 5cm each time and turns left when it is too close to the boundary and turns right if it is too far from the obstacle. After each movement, we will update the global location of the robot itself. The origin point of our global location is the starting point, and the y-axis is the m-line facing the obstacle while the x-axis is the line verticle to the y-axis and faces left. So we can easily know if our robot is on m-line by checking the y value of the current global location of our robot. 

The algorithm uses exactly the same logic for checking when to exit following boundary as bug2 algorithm which is taught in class. When these conditions are satisfied, it will exit the `follow_boundary` function and then judge whether the goal has been reached or it has been trapped. If the goal has not been reached and it has not been trapped, it will then turn towards the goal and start the whole process again until it finds himself trapped or the goal is reached.

After the goal is reached or it makes the judgement that it is trapped, the plot will be generated and the result is printed to the console.

## Assumptions

- The robot is putting on the m-line facing the object and the distance is provided to the robot.

- Because of various errors (rotation error, forwarding error, etc) exist even after we carry out some correction, we will assume the m-line to be a thin band with a witdth of 4.6cm (global location y-value goes from -2.3cm to 2.3cm). And when checking if some points have been reached, we will assume they are reached if our robot approaches within the circle of that object of a radius of 5cm.

